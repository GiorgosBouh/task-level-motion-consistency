import os
import numpy as np
import pandas as pd

# ----------------------------
# 1) Dataset joint order (25 joints) from readme
# ----------------------------
JOINTS = [
    "SpineBase","SpineMid","Neck","Head",
    "ShoulderLeft","ElbowLeft","WristLeft","HandLeft",
    "ShoulderRight","ElbowRight","WristRight","HandRight",
    "HipLeft","KneeLeft","AnkleLeft","FootLeft",
    "HipRight","KneeRight","AnkleRight","FootRight",
    "SpineShoulder","HandTipLeft","ThumbLeft","HandTipRight","ThumbRight"
]
J2I = {j:i for i,j in enumerate(JOINTS)}

# ----------------------------
# 2) Helpers: load, normalize, resample
# ----------------------------
def load_simplified_txt(path: str) -> np.ndarray:
    """
    Reads one simplified .txt file.
    Returns: array of shape (T, 25, 3)
    where T = number of frames, 25 joints, 3 axes.
    """
    data = np.loadtxt(path, delimiter=",")
    if data.ndim == 1:
        data = data.reshape(1, -1)

    if data.shape[1] != 75:
        raise ValueError(f"{os.path.basename(path)} has {data.shape[1]} columns, expected 75.")

    return data.reshape(data.shape[0], 25, 3)

def normalize_by_spinebase(X: np.ndarray) -> np.ndarray:
    """
    Translation normalization: subtract SpineBase (root) coordinates per frame.
    This is standard to remove global position drift.
    """
    root = X[:, J2I["SpineBase"], :]          # (T, 3)
    return X - root[:, None, :]              # (T, 25, 3)

def resample_to_n_frames(X: np.ndarray, n: int = 100) -> np.ndarray:
    """
    Time-normalize each joint-axis trajectory to exactly n frames using linear interpolation.
    """
    T = X.shape[0]
    if T < 2:
        # Edge case: too short to interpolate
        return np.repeat(X, n, axis=0)

    old_t = np.linspace(0, 1, T)
    new_t = np.linspace(0, 1, n)

    Y = np.zeros((n, X.shape[1], X.shape[2]), dtype=float)
    for j in range(X.shape[1]):
        for a in range(X.shape[2]):
            Y[:, j, a] = np.interp(new_t, old_t, X[:, j, a])
    return Y

# ----------------------------
# 3) Kinematic primitives
# ----------------------------
def vector(a: np.ndarray, b: np.ndarray) -> np.ndarray:
    """Vector from a -> b."""
    return b - a

def angle_deg(u: np.ndarray, v: np.ndarray, eps: float = 1e-9) -> np.ndarray:
    """
    Angle between vectors u and v per frame.
    u, v: (T, 3)
    returns: (T,) angle in degrees
    """
    un = np.linalg.norm(u, axis=1) + eps
    vn = np.linalg.norm(v, axis=1) + eps
    cosang = np.sum(u*v, axis=1) / (un * vn)
    cosang = np.clip(cosang, -1.0, 1.0)
    return np.degrees(np.arccos(cosang))

def compute_speed(traj: np.ndarray, fps: float = 30.0) -> np.ndarray:
    """
    traj: (T, 3)
    returns speed magnitude (T-1,)
    """
    dt = 1.0 / fps
    vel = np.diff(traj, axis=0) / dt
    return np.linalg.norm(vel, axis=1)

def normalized_jerk(traj: np.ndarray, fps: float = 30.0, eps: float = 1e-9) -> float:
    """
    A simple smoothness proxy: normalized jerk cost for 3D trajectory.
    Uses 3rd derivative approx via finite differences.
    Returns scalar (lower = smoother).
    """
    dt = 1.0 / fps
    v = np.diff(traj, axis=0) / dt
    a = np.diff(v, axis=0) / dt
    j = np.diff(a, axis=0) / dt   # jerk
    jerk_sq = np.sum(j**2, axis=1)

    # Normalize by movement duration and path length (common practice in smoothness metrics)
    duration = traj.shape[0] * dt
    path_len = np.sum(np.linalg.norm(np.diff(traj, axis=0), axis=1)) + eps

    return float((duration**5) * np.sum(jerk_sq) / (path_len**2 + eps))

# ----------------------------
# 4) Gesture-aware joint selection (based on paper's gesture index 0-8)
#    We'll infer gesture index from filename: Subject_Date_Gesture_Rep_Correct_Position.txt
# ----------------------------
def parse_filename(path: str):
    base = os.path.basename(path).replace(".txt","")
    parts = base.split("_")
    # Expected: SubjectID, DateID, GestureLabel, RepetitionNo, CorrectLabel, Position
    if len(parts) < 6:
        return None
    return {
        "subject": parts[0],
        "date": parts[1],
        "gesture": int(parts[2]),
        "rep": parts[3],
        "correct": int(parts[4]),
        "position": parts[5]
    }

def joints_for_gesture(gesture_idx: int):
    """
    For upper-limb gestures, we focus on the active arm chain.
    0: Elbow Flexion Left
    1: Elbow Flexion Right
    2: Shoulder Flexion Left
    3: Shoulder Flexion Right
    4: Shoulder Abduction Left
    5: Shoulder Abduction Right
    6: Shoulder Forward Elevation (both)
    """
    if gesture_idx in [0, 2, 4]:
        side = "Left"
        return {
            "shoulder": f"Shoulder{side}",
            "elbow": f"Elbow{side}",
            "wrist": f"Wrist{side}",
            "hand": f"Hand{side}",
        }
    if gesture_idx in [1, 3, 5]:
        side = "Right"
        return {
            "shoulder": f"Shoulder{side}",
            "elbow": f"Elbow{side}",
            "wrist": f"Wrist{side}",
            "hand": f"Hand{side}",
        }
    if gesture_idx == 6:
        # Use Right as default, but you can extend to both arms
        return {
            "shoulder": "ShoulderRight",
            "elbow": "ElbowRight",
            "wrist": "WristRight",
            "hand": "HandRight",
        }
    # For leg gestures 7-8 we would switch to Hip/Knee/Ankle/Foot.
    # For now: return None if not upper limb.
    return None

# ----------------------------
# 5) Feature extraction per clip
# ----------------------------
def extract_clip_metrics(path: str, fps: float = 30.0, n_norm: int = 100) -> dict:
    meta = parse_filename(path) or {}
    X = load_simplified_txt(path)                 # (T,25,3)
    T = X.shape[0]

    # (A) Normalize by root (SpineBase) to make comparisons meaningful
    Xn = normalize_by_spinebase(X)

    # (B) Time-normalize to same length (e.g., 100 frames) for fair comparisons
    Xr = resample_to_n_frames(Xn, n=n_norm)

    # (C) Pick joints based on gesture
    gesture = meta.get("gesture", None)
    sel = joints_for_gesture(gesture) if gesture is not None else None

    out = {
        **meta,
        "frames_raw": int(T),
        "frames_norm": int(n_norm),
    }

    if sel is None:
        out["note"] = "Gesture not handled in this demo (likely leg gesture 7-8)."
        return out

    shoulder = Xr[:, J2I[sel["shoulder"]], :]
    elbow    = Xr[:, J2I[sel["elbow"]], :]
    wrist    = Xr[:, J2I[sel["wrist"]], :]
    hand     = Xr[:, J2I[sel["hand"]], :]

    # (D) Key kinematic quantities
    # Elbow angle (for elbow flexion gestures it's primary; for shoulder gestures it's still informative)
    u = vector(elbow, shoulder)   # elbow -> shoulder
    v = vector(elbow, wrist)      # elbow -> wrist
    elbow_ang = angle_deg(u, v)

    # Hand trajectory relative to SpineShoulder (better reference for upper limb tasks)
    trunk_ref = Xr[:, J2I["SpineShoulder"], :]
    hand_rel = hand - trunk_ref

    # Range of motion proxies
    out["elbow_ROM_deg"] = float(np.max(elbow_ang) - np.min(elbow_ang))
    out["hand_path_length"] = float(np.sum(np.linalg.norm(np.diff(hand_rel, axis=0), axis=1)))
    out["hand_displacement"] = float(np.linalg.norm(hand_rel[-1] - hand_rel[0]))

    # Speed / timing proxies
    spd = compute_speed(hand_rel, fps=fps)
    out["hand_peak_speed"] = float(np.max(spd))
    out["hand_mean_speed"] = float(np.mean(spd))

    # Smoothness proxy
    out["hand_normalized_jerk"] = normalized_jerk(hand_rel, fps=fps)

    # Simple “variability inside the clip” proxy: std of hand radius from trunk
    radius = np.linalg.norm(hand_rel, axis=1)
    out["hand_radius_std"] = float(np.std(radius))

    return out

# ----------------------------
# 6) Run on your 3 files and print a simple table
# ----------------------------
files = [
    "/mnt/data/101_18_0_1_1_stand.txt",
    "/mnt/data/101_18_0_6_1_chair.txt",
    "/mnt/data/201_18_2_5_2_wheelchair.txt",
]

rows = [extract_clip_metrics(f) for f in files]
df = pd.DataFrame(rows)

# Keep a clean, simple view
cols = [
    "subject","gesture","correct","position",
    "frames_raw",
    "elbow_ROM_deg","hand_path_length","hand_displacement",
    "hand_peak_speed","hand_mean_speed",
    "hand_normalized_jerk","hand_radius_std",
    "note"
]
cols = [c for c in cols if c in df.columns]
print(df[cols].to_string(index=False))